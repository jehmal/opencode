# Sample Continuation Prompt - OpenCode System

Generated using the advanced continuation prompt system with vector memory integration and optimized prompting techniques.

## Instructions for Next OpenCode Continuation System Agent

You are continuing the implementation of implementing robust continuation prompt system with vector memory integration. The project is 85% complete with significant progress made. Your task is to complete the remaining implementation using advanced prompting techniques and vector memory integration.

## Project Context

- **Working Directory**: /mnt/c/Users/jehma/Desktop/AI/DGMSTT/opencode/packages/opencode
- **Current Phase**: Implementation and optimization
- **Architecture**: Vector memory + MCP servers + advanced prompting
- **Completion Status**: 85% complete

## Memory Search Commands (Chain of Thought Context Recovery)

First, retrieve the current project state and patterns using these optimized queries:

1. Search: "OpenCode Continuation System project snapshot 2025-07"
2. Search: "ai_coding_assistant implementation patterns implementing robust continuation prompt system"
3. Search: "ai_coding_assistant success patterns best practices"
4. Search: "ai_coding_assistant error solutions debugging"
5. Search: "OpenCode Continuation System architecture decisions constraints"

## Completed Components (DO NOT RECREATE)

✅ Vector Memory Integration - Qdrant MCP server with 50+ operations (src/session/continuation-prompt-generator.ts)
✅ Prompting Techniques Research - Multi-agent coordination, CoT, Reflexion, Iterative refinement
✅ Template Structure - Memory-first architecture with parallel execution design
✅ Generator Function - TypeScript implementation with Zod validation
✅ MCP Server Integration - Prompt-tech server for technique optimization

## Critical Files to Reference

- src/session/continuation-prompt-generator.ts - Main generator implementation (lines: 45, 78, 120)
- src/session/system.ts - System prompt integration
- CONTINUATION_PROMPT_TEMPLATE.md - Template documentation

## Required Tasks (USE 3 SUB-AGENTS IN PARALLEL)

Sub-Agent 1: Integration Testing
Test continuation prompt generator with real project data

Implementation Steps:

- Analyze current state and requirements
- Apply Chain of Thought reasoning to break down the task
- Implement solution with iterative refinement
- Use Reflexion to learn from any errors encountered
- Validate implementation meets success criteria

Priority: high
Dependencies: Vector Memory Integration

Sub-Agent 2: Performance Optimization
Optimize prompt generation speed and memory usage

Implementation Steps:

- Analyze current state and requirements
- Apply Chain of Thought reasoning to break down the task
- Implement solution with iterative refinement
- Use Reflexion to learn from any errors encountered
- Validate implementation meets success criteria

Priority: medium

Sub-Agent 3: Documentation
Create comprehensive usage documentation

Implementation Steps:

- Analyze current state and requirements
- Apply Chain of Thought reasoning to break down the task
- Implement solution with iterative refinement
- Use Reflexion to learn from any errors encountered
- Validate implementation meets success criteria

Priority: low

## Integration Requirements

- Maintain backward compatibility with existing session system
- Follow established architectural patterns
- Integrate with vector memory storage system
- Use MCP servers for enhanced capabilities
- Apply prompting techniques for optimization

## Technical Constraints

- Must maintain backward compatibility with existing session system
- Vector storage should use structured text format
- Prompting techniques must be composable and reusable
- Memory searches must be optimized for context recovery

## Success Criteria (Iteratively Refined)

Core Success Metrics:

1. Continuation prompts generate successfully
2. Vector memory integration works correctly
3. Prompting techniques are properly applied
4. System handles edge cases gracefully

Measurable Validation:

- All tests pass without errors
- Performance benchmarks meet requirements
- Code quality standards maintained
- Documentation updated and accurate

Automated Verification:

- CI/CD pipeline validates changes
- Integration tests confirm compatibility
- Memory storage validates project state

## Testing Approach (Iterative Validation)

1. Unit tests for generator functions
2. Integration tests with vector memory
3. End-to-end tests with sample project data
4. Performance benchmarks for prompt generation

## Reflexion Insights & Learning

What We've Accomplished:

- Vector Memory Integration: Qdrant MCP server with 50+ operations
- Prompting Techniques Research: Multi-agent coordination, CoT, Reflexion, Iterative refinement
- Template Structure: Memory-first architecture with parallel execution design
- Generator Function: TypeScript implementation with Zod validation
- MCP Server Integration: Prompt-tech server for technique optimization

Lessons Learned:

- Challenge: Complex metadata validation errors in vector storage
  Solution Applied: Use structured text in information field only, avoid complex metadata
  Future Prevention: Apply this pattern to similar issues

- Challenge: Prompting techniques not being applied consistently
  Solution Applied: Created dedicated generator with technique integration
  Future Prevention: Apply this pattern to similar issues

Self-Reflection for Next Agent:

- Build upon the 85% completion achieved
- Apply proven patterns from completed components
- Use iterative refinement for complex implementations
- Leverage vector memory for context preservation

## Important Notes

- **Chain of Thought**: Use step-by-step reasoning for complex implementations
- **Multi-Agent Coordination**: Leverage parallel sub-agents for efficiency
- **Reflexion**: Learn from previous patterns and apply proven solutions
- **Iterative Refinement**: Progressively improve outputs through multiple passes
- **Vector Memory**: Store all insights and patterns for future reference

## Next Steps

1. Begin with memory searches to restore full context
2. Launch sub-agents in parallel for maximum efficiency
3. Apply prompting techniques throughout implementation
4. Store results in vector memory for future handoffs
5. Validate all success criteria before completion

Start by searching memory for the mentioned queries to understand the current state, then launch your sub-agents to complete the implementation using the advanced prompting techniques outlined above.
