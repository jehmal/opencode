/**
 * Type definitions for Evolution Bridge
 * Connects DGM's evolution engine to DGMO's CLI editor
 */

import { z } from "zod"
import { DGMStatus } from "../dgm/types"

/**
 * Evolution request types
 */
export enum EvolutionRequestType {
  IMPROVE_PERFORMANCE = "improve_performance",
  FIX_BUGS = "fix_bugs",
  ADD_FEATURE = "add_feature",
  REFACTOR_CODE = "refactor_code",
  OPTIMIZE_MEMORY = "optimize_memory",
  ENHANCE_SECURITY = "enhance_security",
  IMPROVE_READABILITY = "improve_readability",
  CUSTOM = "custom",
}

/**
 * Evolution status
 */
export enum EvolutionStatus {
  PENDING = "pending",
  ANALYZING = "analyzing",
  GENERATING = "generating",
  TESTING = "testing",
  VALIDATING = "validating",
  APPLYING = "applying",
  COMPLETED = "completed",
  FAILED = "failed",
  ROLLED_BACK = "rolled_back",
}

/**
 * Performance metrics for tracking improvements
 */
export interface PerformanceMetrics {
  executionTime?: number
  memoryUsage?: number
  cpuUsage?: number
  errorRate?: number
  testCoverage?: number
  codeComplexity?: number
  bundleSize?: number
  customMetrics?: Record<string, number>
}

/**
 * Improvement hypothesis generated by evolution engine
 */
export interface ImprovementHypothesis {
  id: string
  type: EvolutionRequestType
  description: string
  expectedImpact: {
    metric: string
    currentValue: number
    targetValue: number
    improvementPercentage: number
  }[]
  confidence: number
  risks: string[]
  dependencies: string[]
}

/**
 * Evolution request schema
 */
export const EvolutionRequest = z.object({
  id: z.string().describe("Unique request identifier"),
  type: z
    .nativeEnum(EvolutionRequestType)
    .describe("Type of evolution requested"),
  targetFiles: z.array(z.string()).describe("Files to evolve"),
  context: z.object({
    projectPath: z.string().describe("Project root path"),
    language: z.string().describe("Programming language"),
    framework: z.string().optional().describe("Framework being used"),
    testCommand: z.string().optional().describe("Command to run tests"),
    performanceCommand: z
      .string()
      .optional()
      .describe("Command to measure performance"),
  }),
  constraints: z.object({
    maxExecutionTime: z.number().default(300000).describe("Max time in ms"),
    preserveApi: z.boolean().default(true).describe("Preserve public API"),
    maintainBackwardCompatibility: z.boolean().default(true),
    requireTests: z.boolean().default(true).describe("Require passing tests"),
    minTestCoverage: z.number().min(0).max(100).optional(),
  }),
  metrics: z.object({
    baseline: z.record(z.number()).describe("Baseline performance metrics"),
    targets: z
      .record(z.number())
      .optional()
      .describe("Target metrics to achieve"),
  }),
  customPrompt: z.string().optional().describe("Custom evolution instructions"),
  metadata: z.record(z.any()).optional(),
})

export type EvolutionRequest = z.infer<typeof EvolutionRequest>

/**
 * Evolution result
 */
export interface EvolutionResult {
  id: string
  requestId: string
  status: EvolutionStatus
  hypothesis: ImprovementHypothesis
  changes: {
    file: string
    originalContent: string
    evolvedContent: string
    diff: string
    explanation: string
  }[]
  metrics: {
    before: PerformanceMetrics
    after: PerformanceMetrics
    improvement: Record<string, number>
  }
  testResults: {
    passed: boolean
    totalTests: number
    passedTests: number
    failedTests: number
    coverage?: number
    details: string
  }
  validationResults: {
    apiCompatibility: boolean
    backwardCompatibility: boolean
    securityCheck: boolean
    performanceRegression: boolean
    details: string[]
  }
  rollbackInfo?: {
    available: boolean
    snapshotId: string
    command: string
  }
  timestamp: number
  duration: number
}

/**
 * Evolution lifecycle events
 */
export enum EvolutionEvent {
  REQUEST_CREATED = "evolution:request:created",
  ANALYSIS_STARTED = "evolution:analysis:started",
  HYPOTHESIS_GENERATED = "evolution:hypothesis:generated",
  GENERATION_STARTED = "evolution:generation:started",
  GENERATION_COMPLETED = "evolution:generation:completed",
  TESTING_STARTED = "evolution:testing:started",
  TESTING_COMPLETED = "evolution:testing:completed",
  VALIDATION_STARTED = "evolution:validation:started",
  VALIDATION_COMPLETED = "evolution:validation:completed",
  APPLYING_CHANGES = "evolution:applying:changes",
  EVOLUTION_COMPLETED = "evolution:completed",
  EVOLUTION_FAILED = "evolution:failed",
  ROLLBACK_STARTED = "evolution:rollback:started",
  ROLLBACK_COMPLETED = "evolution:rollback:completed",
  METRICS_UPDATED = "evolution:metrics:updated",
}

/**
 * Evolution session for tracking multiple related evolutions
 */
export interface EvolutionSession {
  id: string
  name: string
  description: string
  requests: string[] // Request IDs
  startTime: number
  endTime?: number
  totalImprovements: number
  aggregateMetrics: {
    performanceGain: number
    memoryReduction: number
    errorReduction: number
    testCoverageIncrease: number
  }
  status: "active" | "completed" | "failed"
}

/**
 * Evolution configuration
 */
export const EvolutionConfig = z.object({
  enabled: z.boolean().default(true).describe("Enable evolution features"),
  autoEvolve: z
    .boolean()
    .default(false)
    .describe("Automatically evolve on performance degradation"),
  evolutionThreshold: z.object({
    performanceDegradation: z
      .number()
      .default(20)
      .describe("Percentage threshold"),
    errorRateIncrease: z.number().default(10).describe("Percentage threshold"),
    testFailureRate: z.number().default(5).describe("Percentage threshold"),
  }),
  maxConcurrentEvolutions: z
    .number()
    .default(3)
    .describe("Max parallel evolutions"),
  evolutionTimeout: z
    .number()
    .default(600000)
    .describe("Evolution timeout in ms"),
  rollbackOnFailure: z
    .boolean()
    .default(true)
    .describe("Auto rollback on failure"),
  requireApproval: z
    .boolean()
    .default(true)
    .describe("Require user approval before applying"),
  telemetry: z.object({
    trackMetrics: z.boolean().default(true),
    reportingInterval: z
      .number()
      .default(60000)
      .describe("Metrics reporting interval"),
    metricsEndpoint: z.string().optional(),
  }),
})

export type EvolutionConfig = z.infer<typeof EvolutionConfig>

/**
 * Evolution Bridge interface
 */
export interface IEvolutionBridge {
  /**
   * Request an evolution
   */
  requestEvolution(request: EvolutionRequest): Promise<EvolutionResult>

  /**
   * Get evolution status
   */
  getEvolutionStatus(requestId: string): Promise<EvolutionResult>

  /**
   * Cancel an ongoing evolution
   */
  cancelEvolution(requestId: string): Promise<void>

  /**
   * Apply evolution changes
   */
  applyEvolution(requestId: string): Promise<void>

  /**
   * Rollback evolution changes
   */
  rollbackEvolution(requestId: string): Promise<void>

  /**
   * Get evolution history
   */
  getEvolutionHistory(limit?: number): Promise<EvolutionResult[]>

  /**
   * Get performance metrics
   */
  getPerformanceMetrics(targetFiles: string[]): Promise<PerformanceMetrics>

  /**
   * Create evolution session
   */
  createSession(name: string, description: string): Promise<EvolutionSession>

  /**
   * Get active sessions
   */
  getActiveSessions(): Promise<EvolutionSession[]>

  /**
   * Health check
   */
  healthCheck(): Promise<{
    status: DGMStatus
    activeEvolutions: number
    queuedEvolutions: number
    completedEvolutions: number
    successRate: number
  }>

  /**
   * Register event listener
   */
  on(event: EvolutionEvent, handler: (data: any) => void): void

  /**
   * Unregister event listener
   */
  off(event: EvolutionEvent, handler: (data: any) => void): void
}
